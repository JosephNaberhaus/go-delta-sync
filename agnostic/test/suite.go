package test

import (
	"bufio"
	"encoding/json"
	"errors"
	"github.com/JosephNaberhaus/go-delta-sync/agnostic"
	"github.com/JosephNaberhaus/go-delta-sync/agnostic/blocks/types"
	"github.com/JosephNaberhaus/go-delta-sync/agnostic/blocks/value"
	"os"
	"strings"
)

// A collection of tests
type Suite []Case

func ComposeSuites(suites ...Suite) Suite {
	numCases := 0
	for _, s := range suites {
		numCases += len(s)
	}

	composed := make(Suite, 0, numCases)
	for _, s := range suites {
		composed = append(composed, s...)
	}

	return composed
}

func (s Suite) RemoveLimitations(limitations Limitations) (suite Suite, removed []RemovedCase) {
	suite = make(Suite, 0)
	removed = make([]RemovedCase, 0)

	for _, c := range s {
		justification, inLimitations := limitations[c.Name]
		if !inLimitations {
			suite = append(suite, c)
		} else {
			removed = append(removed, RemovedCase{Case: &c, Justification: justification})
		}
	}

	return
}

// Generates the agnostic code (methods and models) for all test suites
func (s Suite) GenerateAgnostic(implementation agnostic.Implementation) {
	implementation.Model("TestModel", s.GetModelFields()...)

	for _, c := range s {
		if c.Returns == nil {
			c.Generator(implementation.Method("TestModel", c.Name, c.Parameters...))
		} else {
			c.Generator(implementation.ReturnMethod("TestModel", c.Name, c.Returns, c.Parameters...))
		}
	}
}

// Generates the test code (the assertions) for all test suites
func (s Suite) GenerateTests(implementation Implementation) {
	for _, c := range s {
		implementation.Test(c)
	}
}

func (s Suite) GetModelFields() []agnostic.Field {
	fields := make([]agnostic.Field, 0)
	fieldTypes := make(map[string]types.Any)
	for _, c := range s {
		for _, field := range c.ModelFields {
			existingType, ok := fieldTypes[field.Name]
			if ok {
				// Ensure that the two fields have the same type
				if existingType != field.Type {
					panic(errors.New("multiple requests for field \"" + field.Name + "\" with different types"))
				}
			} else {
				fields = append(fields, field)
				fieldTypes[field.Name] = field.Type
			}
		}
	}

	return fields
}

var AllSuites = ComposeSuites(
	ArraySuite,
	MapSuite,
	ForSuite,
	IfSuite,
	ValueSuite,
)

// A function that takes the given body implementation and the method that the
// test will car
type GenerateBodyFunc func(body agnostic.BodyImplementation)

// A method should be created
type Case struct {
	Name        string           // Name of the test case (must be unique)
	Description string           // Describes what the test case is for
	ModelFields []agnostic.Field // Fields that need to exist on TestModel for this test
	Parameters  []agnostic.Field // Parameters that the generated test method will take in
	Returns     types.Any        // The return type of the method or nil if it returns nothing
	Generator   GenerateBodyFunc // Function that generates the method that the test will target
	Facts       []Fact           // Facts about the Test
}

// A change that happens to the model as a result of a method call
type SideEffect struct {
	FieldName     string    // Name of the field
	ExpectedValue value.Any // The expected value of the field
}

func NewSideEffect(fieldName string, expectedValue value.Any) SideEffect {
	return SideEffect{
		FieldName:     fieldName,
		ExpectedValue: expectedValue,
	}
}

// An assertion that calling the method with the given inputs will result in
// the given side effects and output
type Fact struct {
	Name        string       // A descriptive name for the fact (must be unique in the context of a case)
	Inputs      []value.Any  // Values to pass in a parameters or nil
	SideEffects []SideEffect // Side effects of the method call or nil
	Output      value.Any    // The output of the method or nil
}

// Map from a test case name to a justification of why the test doesn't work
// for a given language
type Limitations map[string]string

func LoadLimitations(fileName string) (limitations Limitations, err error) {
	file, err := os.Open(fileName)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	limitations = make(Limitations)
	err = json.NewDecoder(file).Decode(&limitations)
	if err != nil {
		return nil, err
	}

	return
}

type RemovedCase struct {
	Case          *Case
	Justification string
}

func GenerateLimitationReport(fileName string, removedCases []RemovedCase) error {
	var sb strings.Builder

	sb.WriteString("# Limitations\n")
	sb.WriteString("This file is auto-generated by the `generate-test` script. It reflects the test cases fail in this language implementation.\n")
	if len(removedCases) == 0 {
		sb.WriteString("This language has no recorded limitations")
	} else {
		for _, r := range removedCases {
			sb.WriteString("####")
			sb.WriteString(r.Case.Description)
			sb.WriteString("\n")

			sb.WriteString("Unsupported because ")
			sb.WriteString(r.Justification)
			sb.WriteString("\n")
		}
	}

	file, err := os.Create(fileName)
	if err != nil {
		return err
	}

	writer := bufio.NewWriter(file)
	_, err = writer.WriteString(sb.String())
	if err != nil {
		return err
	}

	err = writer.Flush()
	if err != nil {
		return err
	}

	err = file.Close()
	if err != nil {
		return err
	}

	return nil
}
